# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017-present, Fantix King
# This file is distributed under the same license as the GINO package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: GINO 0.7.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-08-21 12:19+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Language-Team: Chinese (https://www.transifex.com/decentfox-studio/teams/84194/zh/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../gino.rst:2
msgid "gino package"
msgstr ""

#: ../../gino.rst:5
msgid "Subpackages"
msgstr ""

#: ../../gino.rst:13
msgid "Submodules"
msgstr ""

#: ../../gino.rst:16
msgid "gino.api module"
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino:1
msgid "Bases: :class:`sqlalchemy.sql.schema.MetaData`"
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino:1
msgid "All-in-one API class of GINO, providing several shortcuts."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino:3
msgid ""
"This class is a subclass of SQLAlchemy :class:`~sqlalchemy.schema.MetaData`,"
" therefore its instances can be used as a normal "
":class:`~sqlalchemy.schema.MetaData` object, e.g. used in `Alembic "
"<http://alembic.zzzcomputing.com/>`_. In usual cases, you would want to "
"define one global :class:`~.Gino` instance, usually under the name of "
"``db``, representing the database used in your application."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino:10
msgid ""
"You may define tables in `the official way <http://bit.ly/2G25fdc>`_ "
"SQLAlchemy core recommended, but more often in GINO we define model classes "
"with ``db.Model`` as their parent class to represent tables, for its "
"objective interface and CRUD operations. Please read :doc:`crud` for more "
"information."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino:16
msgid ""
"For convenience, :class:`Gino` instance delegated all properties publicly "
"exposed by :mod:`sqlalchemy`, so that you can define tables / models without"
" importing :mod:`sqlalchemy`::"
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino:22
msgid ""
"Similar to :class:`~sqlalchemy.schema.MetaData`, a :class:`~.Gino` object "
"can bind to a :class:`~gino.engine.GinoEngine` instance, hereby allowing "
"`\"implicit execution\" <http://bit.ly/2oTUcKY>`_ through the ``gino`` "
"extension on :class:`~sqlalchemy.sql.expression.Executable` or "
":class:`~sqlalchemy.schema.SchemaItem` constructs::"
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino:31
msgid ""
"Differently, GINO encourages the use of implicit execution and manages "
"transactional context correctly."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino:34
msgid "Binding to a connection object is not supported."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino:36
msgid ""
"To set a bind property, you can simply set your "
":class:`~gino.engine.GinoEngine` object on :attr:`db.bind <Gino.bind>`, or "
"set it to ``None`` to unbind. However, the creation of engine usually "
"happens at the same time. Therefore, GINO provided several convenient ways "
"doing so:"
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino:42
msgid ":meth:`~Gino.with_bind` returning an asynchronous context manager::"
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino:46
msgid ":meth:`~Gino.set_bind` and :meth:`~Gino.pop_bind`::"
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino:51
msgid "Directly ``await`` on :class:`~.Gino` instance::"
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino:58
msgid "SQLAlchemy allows creating the engine by::"
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino:62
msgid ""
"While in GINO this only sets a string to :attr:`~.Gino.bind`, because "
"creating an engine requires ``await``, which is excatly what "
":meth:`~.Gino.set_bind` does."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino:66
msgid ""
"At last, :class:`Gino` delegated all query APIs on the bound "
":class:`~.engine.GinoEngine`."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino:0
#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.create:0
#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.delete:0
#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.get:0
#: ../../../gino/crud.pydocstring of gino.crud.UpdateRequest.apply:0
#: ../../../gino/engine.pydocstring of
#: gino.engine.GinoConnection.execution_options:0
#: ../../../gino/engine.pydocstring of
#: gino.engine.GinoConnection.get_raw_connection:0
#: ../../../gino/engine.pydocstring of gino.engine.GinoEngine.acquire:0
msgid "Parameters"
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino:70
msgid ""
"A :class:`~.engine.GinoEngine` instance to bind. Also accepts string or "
":class:`~sqlalchemy.engine.url.URL`, which will be passed to "
":func:`~gino.create_engine` when this :class:`Gino` instance is awaited. "
"Default is ``None``."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino:75
msgid ""
"A :class:`tuple` of base class and mixin classes to create the "
":attr:`~.Gino.Model` class. Default is :class:`(CRUDModel, ) "
"<gino.crud.CRUDModel>`."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino:78
msgid ""
"Boolean value to control the installation of the ``gino`` extension on "
":class:`~sqlalchemy.sql.expression.Executable` for implicit execution. "
"Default is to install (``True``)."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino:82
msgid ""
"Boolean value to control the installation of the ``gino`` extension on "
":class:`~sqlalchemy.schema.SchemaItem` for implicit execution. Default is to"
" install (``True``)."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino:86
msgid ""
"Boolean value to control the installation of the two ``gino`` extensions. "
"``False`` for no extension at all, while it depends on the two individual "
"switches when this is set to ``True`` (default)."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino:90
msgid "Other arguments accepted by :class:`~sqlalchemy.schema.MetaData`."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino.Model:1
msgid ""
"Declarative base class for models, subclass of "
":class:`gino.declarative.Model`. Defining subclasses of this class will "
"result new tables added to this :class:`Gino` metadata."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino.acquire:1
msgid ""
"A delegate of :meth:`GinoEngine.acquire() <.engine.GinoEngine.acquire>`."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino.all:1
msgid "A delegate of :meth:`GinoEngine.all() <.engine.GinoEngine.all>`."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino.bind:1
msgid "An :class:`~.engine.GinoEngine` to which this :class:`Gino` is bound."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino.bind:3
msgid ""
"This is a simple property with no getter or setter hook - what you set is "
"what you get. To achieve the same result as it is in SQLAlchemy - setting a "
"string or :class:`~sqlalchemy.engine.url.URL` and getting an engine "
"instance, use :meth:`set_bind` (or ``await`` on this :class:`Gino` object "
"after setting a string or :class:`~sqlalchemy.engine.url.URL`)."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino.compile:1
msgid ""
"A delegate of :meth:`GinoEngine.compile() <.engine.GinoEngine.compile>`."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino.first:1
msgid "A delegate of :meth:`GinoEngine.first() <.engine.GinoEngine.first>`."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino.iterate:1
msgid ""
"A delegate of :meth:`GinoEngine.iterate() <.engine.GinoEngine.iterate>`."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino.model_base_classes:1
msgid "Overridable default model classes to build the :attr:`Model`."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino.model_base_classes:3
msgid "Default is :class:`(CRUDModel, ) <gino.crud.CRUDModel>`."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino.no_delegate:1
msgid ""
"A set of symbols from :mod:`sqlalchemy` which is not delegated by "
":class:`Gino`."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino.pop_bind:1
msgid "Unbind self, and return the bound engine."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino.pop_bind:3
msgid "This is usually used in a chained call to close the engine::"
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino.pop_bind:0
#: ../../../gino/api.pydocstring of gino.api.Gino.set_bind:0
#: ../../../gino/api.pydocstring of gino.api.Gino.with_bind:0
#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.create:0
#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.get:0
#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.lookup:0
#: ../../../gino/crud.pydocstring of gino.crud.UpdateRequest.apply:0
#: ../../../gino/engine.pydocstring of
#: gino.engine.GinoConnection.get_raw_connection:0
#: ../../../gino/engine.pydocstring of gino.engine.GinoEngine.acquire:0
#: ../../../gino/engine.pydocstring of
#: gino.engine.GinoEngine.current_connection:0
#: ../../../gino/engine.pydocstring of gino.engine.GinoEngine.transaction:0
msgid "Returns"
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino.pop_bind:7
msgid ":class:`~.engine.GinoEngine` or ``None`` if self is not bound."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino.query_executor:1
msgid ""
"The overridable ``gino`` extension class on "
":class:`~sqlalchemy.sql.expression.Executable`."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino.query_executor:4
msgid ""
"This class will be set as the getter method of the property ``gino`` on "
":class:`~sqlalchemy.sql.expression.Executable` and its subclasses, if "
"``ext`` and ``query_ext`` arguments are both ``True``. Default is "
":class:`GinoExecutor`."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino.scalar:1
msgid "A delegate of :meth:`GinoEngine.scalar() <.engine.GinoEngine.scalar>`."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino.set_bind:1
msgid "Bind self to the given :class:`~.engine.GinoEngine` and return it."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino.set_bind:3
msgid ""
"If the given ``bind`` is a string or :class:`~sqlalchemy.engine.url.URL`, "
"all arguments will be sent to :func:`~gino.create_engine` to create a new "
"engine, and return it."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino.set_bind:7
msgid ":class:`~.engine.GinoEngine`"
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino.status:1
msgid "A delegate of :meth:`GinoEngine.status() <.engine.GinoEngine.status>`."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino.transaction:1
msgid ""
"A delegate of :meth:`GinoEngine.transaction() "
"<.engine.GinoEngine.transaction>`."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino.with_bind:1
msgid ""
"Shortcut for :meth:`set_bind` and :meth:`pop_bind` plus closing engine."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino.with_bind:3
msgid ""
"This method accepts the same arguments of :func:`~gino.create_engine`. This "
"allows inline creating an engine and binding self on enter, and unbinding "
"self and closing the engine on exit::"
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.Gino.with_bind:11
msgid "An asynchronous context manager."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.GinoExecutor:1
#: ../../../gino/crud.pydocstring of gino.crud.Alias:1
#: ../../../gino/crud.pydocstring of gino.crud.UpdateRequest:1
#: ../../../gino/declarative.pydocstring of gino.declarative.ColumnAttribute:1
#: ../../../gino/declarative.pydocstring of gino.declarative.Model:1
#: ../../../gino/engine.pydocstring of gino.engine.GinoConnection:1
#: ../../../gino/engine.pydocstring of gino.engine.GinoEngine:1
#: ../../../gino/json_support.pydocstring of gino.json_support.JSONProperty:1
#: ../../../gino/loader.pydocstring of gino.loader.Loader:1
#: ../../../gino/schema.pydocstring of gino.schema.AsyncSchemaTypeMixin:1
#: ../../../gino/schema.pydocstring of gino.schema.AsyncVisitor:1
#: ../../../gino/schema.pydocstring of gino.schema.GinoSchemaVisitor:1
#: ../../../gino/transaction.pydocstring of gino.transaction.GinoTransaction:1
msgid "Bases: :class:`object`"
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.GinoExecutor:1
msgid ""
"The default ``gino`` extension on "
":class:`~sqlalchemy.sql.expression.Executable` constructs for implicit "
"execution."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.GinoExecutor:5
msgid ""
"Instances of this class are created when visiting the ``gino`` property of "
":class:`~sqlalchemy.sql.expression.Executable` instances (also referred as "
"queries or clause elements), for example::"
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.GinoExecutor:11
msgid ""
"This allows GINO to add the asynchronous query APIs (:meth:`all`, "
":meth:`first`, :meth:`scalar`, :meth:`status`, :meth:`iterate`) to "
"SQLAlchemy query clauses without messing up with existing synchronous ones. "
"Calling these asynchronous query APIs has the same restriction - the "
"relevant metadata (the :class:`Gino` instance) must be bound to an engine, "
"or an :exc:`AttributeError` will be raised."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.GinoExecutor:20
msgid ""
"Executable clause elements that are completely irrelevant with any table - "
"for example ``db.select([db.text('now()')])`` - has no metadata, hence no "
"engine. Therefore, this will always fail::"
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.GinoExecutor:26
msgid ""
"You should use :meth:`conn.scalar() <.engine.GinoConnection.scalar>`, "
":meth:`engine.scalar() <.engine.GinoEngine.scalar>` or even "
":meth:`db.scalar() <.Gino.scalar>` in this case."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.GinoExecutor.all:1
msgid ""
"Returns :meth:`engine.all() <.engine.GinoEngine.all>` with this query as the"
" first argument, and other arguments followed, where ``engine`` is the "
":class:`~.engine.GinoEngine` to which the metadata (:class:`Gino`) is bound,"
" while metadata is found in this query."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.GinoExecutor.first:1
msgid ""
"Returns :meth:`engine.first() <.engine.GinoEngine.first>` with this query as"
" the first argument, and other arguments followed, where ``engine`` is the "
":class:`~.engine.GinoEngine` to which the metadata (:class:`Gino`) is bound,"
" while metadata is found in this query."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.GinoExecutor.iterate:1
msgid ""
"Returns :meth:`engine.iterate() <.engine.GinoEngine.iterate>` with this "
"query as the first argument, and other arguments followed, where ``engine`` "
"is the :class:`~.engine.GinoEngine` to which the metadata (:class:`Gino`) is"
" bound, while metadata is found in this query."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.GinoExecutor.load:1
msgid "Shortcut to set execution option ``loader`` in a chaining call."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.GinoExecutor.load:3
msgid "For example to load ``Book`` instances with their authors::"
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.GinoExecutor.load:8
#: ../../../gino/api.pydocstring of gino.api.GinoExecutor.model:3
#: ../../../gino/api.pydocstring of gino.api.GinoExecutor.return_model:3
#: ../../../gino/api.pydocstring of gino.api.GinoExecutor.timeout:3
msgid ""
"Read :meth:`~gino.engine.GinoConnection.execution_options` for more "
"information."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.GinoExecutor.model:1
msgid "Shortcut to set execution option ``model`` in a chaining call."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.GinoExecutor.query:1
msgid "Get back the chained :class:`~sqlalchemy.sql.expression.Executable`."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.GinoExecutor.query:3
msgid ""
"In a chained query calls, occasionally the previous query clause is needed "
"after a ``.gino.`` chain, you can use ``.query.`` to resume the chain back. "
"For example::"
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.GinoExecutor.return_model:1
msgid "Shortcut to set execution option ``return_model`` in a chaining call."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.GinoExecutor.scalar:1
msgid ""
"Returns :meth:`engine.scalar() <.engine.GinoEngine.scalar>` with this query "
"as the first argument, and other arguments followed, where ``engine`` is the"
" :class:`~.engine.GinoEngine` to which the metadata (:class:`Gino`) is "
"bound, while metadata is found in this query."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.GinoExecutor.status:1
msgid ""
"Returns :meth:`engine.status() <.engine.GinoEngine.status>` with this query "
"as the first argument, and other arguments followed, where ``engine`` is the"
" :class:`~.engine.GinoEngine` to which the metadata (:class:`Gino`) is "
"bound, while metadata is found in this query."
msgstr ""

#: ../../../gino/api.pydocstring of gino.api.GinoExecutor.timeout:1
msgid "Shortcut to set execution option ``timeout`` in a chaining call."
msgstr ""

#: ../../gino.rst:24
msgid "gino.crud module"
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.Alias:1
#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.alias:1
msgid "Experimental proxy for table alias on model."
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel:1
msgid "Bases: :class:`gino.declarative.Model`"
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel:1
msgid "The base class for models with CRUD support."
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel:3
msgid ""
"Don't inherit from this class directly, because it has no metadata. Use "
":attr:`db.Model <gino.api.Gino.Model>` instead."
msgstr ""

#: ../../../gino/crud.pydocstring of
#: gino.crud.CRUDModel.append_where_primary_key:1
msgid ""
"Append where clause to locate this model instance by primary on the given "
"query, and return the new query."
msgstr ""

#: ../../../gino/crud.pydocstring of
#: gino.crud.CRUDModel.append_where_primary_key:4
msgid ""
"This is mostly used internally in GINO, but also available for such usage::"
msgstr ""

#: ../../../gino/crud.pydocstring of
#: gino.crud.CRUDModel.append_where_primary_key:9
msgid "which is identical to::"
msgstr ""

#: ../../../gino/crud.pydocstring of
#: gino.crud.CRUDModel.append_where_primary_key:13
msgid "Use :meth:`.lookup` instead."
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.create:1
msgid ""
"This ``create`` behaves a bit different on model classes compared to model "
"instances."
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.create:4
msgid ""
"On model classes, ``create`` will create a new model instance and insert it "
"into database. On model instances, ``create`` will just insert the instance "
"into the database."
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.create:8
msgid ""
"Under the hood :meth:`.create` uses ``INSERT ... RETURNING ...`` to create "
"the new model instance and load it with database default data if not "
"specified."
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.create:12
msgid "Some examples::"
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.create:18
#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.get:12
msgid ""
"A :class:`~gino.engine.GinoEngine` to execute the ``INSERT`` statement with,"
" or ``None`` (default) to use the bound engine on the metadata "
"(:class:`~gino.api.Gino`)."
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.create:22
#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.delete:28
#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.get:16
#: ../../../gino/crud.pydocstring of gino.crud.UpdateRequest.apply:6
msgid ""
"Seconds to wait for the database to finish executing, ``None`` for wait "
"forever. By default it will use the ``timeout`` execution option value if "
"unspecified."
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.create:26
msgid ""
"Keyword arguments are pairs of attribute names and their initial values. "
"Only available when called on a model class."
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.create:29
msgid "The instance of this model class (newly created or existing)."
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.delete:1
msgid ""
"Similar to :meth:`.update`, this ``delete`` is also different on model "
"classes than on model instances."
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.delete:4
msgid ""
"On model classes ``delete`` is an attribute of type "
":class:`~sqlalchemy.sql.expression.Delete` for massive deletes, for "
"example::"
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.delete:10
msgid ""
"Similarly you can add a :meth:`~sqlalchemy.sql.expression.Delete.returning` "
"clause to the query and it shall return the deleted rows as model objects."
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.delete:13
msgid ""
"And on model instances, ``delete()`` is a method to remove the corresponding"
" row in the database of this model instance. and returns the status returned"
" from the database::"
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.delete:21
msgid ""
"``delete()`` only removes the row from database, it does not affect the "
"current model instance."
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.delete:24
msgid ""
"An optional :class:`~gino.engine.GinoEngine` if current metadata "
"(:class:`~gino.api.Gino`) has no bound engine, or specifying a different "
":class:`~gino.engine.GinoEngine` to execute the ``DELETE``."
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.distinct:1
msgid ""
"Experimental loader feature to yield only distinct instances by given "
"columns."
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.get:1
msgid "Get an instance of this model class by primary key."
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.get:3
#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.select:13
msgid "For example::"
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.get:7
msgid ""
"Value of the primary key. For composite primary keys this should be a tuple "
"of values for all keys in database order, or a dict of names (or position "
"numbers in database order starting from zero) of all primary keys to their "
"values."
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.get:20
msgid "An instance of this model class, or ``None`` if no such row."
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.load:1
msgid ""
"Populates a :class:`.loader.Loader` instance to be used by the ``loader`` "
"execution option in order to customize the loading behavior to load "
"specified fields into instances of this model."
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.load:5
msgid ""
"The basic usage of this method is to provide the ``loader`` execution option"
" (if you are looking for reloading the instance from database, check "
":meth:`.get` or :attr:`.query`) for a given query."
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.load:10
msgid ""
"This method takes both positional arguments and keyword arguments with very "
"different meanings. The positional arguments should be column names as "
"strings, specifying only these columns should be loaded into the model "
"instance (other values are discarded even if they are retrieved from "
"database). Meanwhile, the keyword arguments should be loaders for instance "
"attributes. For example::"
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.load:21
msgid ""
"``gino.load`` is a shortcut for setting the execution option ``loader``."
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.load:24
msgid ""
"This will populate a ``User`` instance with only ``id`` and ``name`` values,"
" all the rest are simply ``None`` even if the query actually returned all "
"the column values."
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.load:33
msgid ""
"This will load two instances of model ``User`` and ``Team``, returning the "
"``User`` instance with ``u.team`` set to the ``Team`` instance."
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.load:36
msgid ""
"Both positional and keyword arguments can be used ath the same time. If they"
" are both omitted, like ``Team.load()``, it is equivalent to just ``Team`` "
"as a loader."
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.load:40
msgid ""
"Additionally, a :class:`.loader.Loader` instance can also be used to "
"generate queries, as its structure is usually the same as the query::"
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.load:45
msgid "This generates a query like this::"
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.load:51
msgid ""
"The :class:`~.loader.Loader` delegates attributes on the ``query``, so "
"``.query`` can be omitted. The ``LEFT JOIN`` is built-in behavior, while the"
" ``ON`` clause is generated based on foreign key. If there is no foreign "
"key, or the condition should be customized, you can use this::"
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.load:60
msgid ""
"And you can use both :meth:`~.load` and :meth:`~.on` at the same time in a "
"chain, in whatever order suits you."
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.load:65
#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.select:27
msgid ":meth:`~gino.engine.GinoConnection.execution_options`"
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.lookup:1
msgid "Generate where-clause expression to locate this model instance."
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.lookup:3
msgid ""
"By default this method uses current values of all primary keys, and you can "
"override it to behave differently. Most instance-level CRUD operations "
"depend on this method internally. Particularly while :meth:`.lookup` is "
"called in :meth:`.update`, the where condition is used in "
":meth:`.UpdateRequest.apply`, so that queries like ``UPDATE ... SET id = NEW"
" WHERE id = OLD`` could work correctly."
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.on:1
msgid "Customize the on-clause for the auto-generated outer join query."
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.on:5
msgid ""
"This has no effect when provided as the ``loader`` execution option for a "
"given query."
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.on:10
msgid ":meth:`.load`"
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.query:1
msgid ""
"Get a SQLAlchemy query clause of the table behind this model. This equals to"
" :func:`sqlalchemy.select([self.__table__]) "
"<sqlalchemy.sql.expression.select>`. If this attribute is retrieved on a "
"model instance, then a where clause to locate this instance by its primary "
"key is appended to the returning query clause. This model type is set as the"
" execution option ``model`` in the returning clause, so by default the query"
" yields instances of this model instead of database rows."
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.select:1
msgid "Build a query to retrieve only specified columns from this table."
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.select:3
msgid ""
"This method accepts positional string arguments as names of attributes to "
"retrieve, and returns a :class:`~sqlalchemy.sql.expression.Select` for "
"query. The returning query object is always set with two execution options:"
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.select:7
msgid "``model`` is set to this model type"
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.select:8
msgid "``return_model`` is set to ``False``"
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.select:10
msgid ""
"So that by default it always return rows instead of model instances, while "
"column types can be inferred correctly by the ``model`` option."
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.select:18
msgid ""
"If :meth:`.select` is invoked on a model instance, then a ``WHERE`` clause "
"to locate this instance by its primary key is appended to the returning "
"query clause. This is useful when you want to retrieve a latest value of a "
"field on current model instance from database::"
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.to_dict:1
msgid "Convenient method to generate a dict from this model instance."
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.to_dict:3
msgid ""
"Keys will be attribute names, while values are loaded from memory (not from "
"database). If there are :class:`~gino.json_support.JSONProperty` attributes "
"in this model, their source JSON field will not be included in the returning"
" dict - instead the JSON attributes will be."
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.to_dict:10
msgid ":mod:`.json_support`"
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.update:1
msgid ""
"This ``update`` behaves quite different on model classes rather than model "
"instances."
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.update:4
msgid ""
"On model classes, ``update`` is an attribute of type "
":class:`~sqlalchemy.sql.expression.Update` for massive updates, for "
"example::"
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.update:10
msgid ""
"Like :attr:`.query`, the update query also has the ``model`` execution "
"option of this model, so if you use the "
":meth:`~sqlalchemy.sql.expression.Update.returning` clause, the query shall "
"return model objects."
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.update:15
msgid ""
"However on model instances, ``update()`` is a method which accepts keyword "
"arguments only and returns an :class:`.UpdateRequest` to update this single "
"model instance. The keyword arguments are pairs of attribute names and new "
"values. This is the same as :meth:`.UpdateRequest.update`, feel free to read"
" more about it. A normal usage example would be like this::"
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.CRUDModel.update:23
msgid ""
"Here, the :meth:`await ... apply() <.UpdateRequest.apply>` executes the "
"actual ``UPDATE`` SQL in the database, while ``user.update()`` only makes "
"changes in the memory, and collect all changes into an "
":class:`.UpdateRequest` instance."
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.UpdateRequest:1
msgid ""
"A collection of attributes and their new values to update on one model "
"instance."
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.UpdateRequest:4
msgid ""
":class:`.UpdateRequest` instances are created by :attr:`.CRUDModel.update`, "
"don't instantiate manually unless required. Every :class:`.UpdateRequest` "
"instance is bound to one model instance, all updates are for that one "
"specific model instance and its database row."
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.UpdateRequest.apply:1
msgid "Apply pending updates into database by executing an ``UPDATE`` SQL."
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.UpdateRequest.apply:3
msgid ""
"A :class:`~gino.engine.GinoEngine` to execute the SQL, or ``None`` (default)"
" to use the bound engine in the metadata."
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.UpdateRequest.apply:10
msgid "``self`` for chaining calls."
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.UpdateRequest.update:1
msgid ""
"Set given attributes on the bound model instance, and add them into the "
"update collections for :meth:`.apply`."
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.UpdateRequest.update:4
msgid ""
"Given keyword-only arguments are pairs of attribute names and values to "
"update. This is not a coroutine, calling :meth:`.update` will have instant "
"effect on the bound model instance - its in-memory values will be updated "
"immediately. Therefore this can be used individually as a shortcut to update"
" several attributes in a batch::"
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.UpdateRequest.update:12
msgid ""
":meth:`.update` returns ``self`` for chaining calls to either :meth:`.apply`"
" or another :meth:`.update`. If one attribute is updated several times by "
"the same :class:`.UpdateRequest`, then only the last value is remembered for"
" :meth:`.apply`."
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.UpdateRequest.update:17
msgid ""
"Updated values can be SQLAlchemy expressions, for example an atomic "
"increment for user balance looks like this::"
msgstr ""

#: ../../../gino/crud.pydocstring of gino.crud.UpdateRequest.update:24
msgid ""
"Expression values will not affect the in-memory attribute value on "
":meth:`.update` before :meth:`.apply`, because it has no knowledge of the "
"latest value in the database. After :meth:`.apply` the new value will be "
"automatically reloaded from database with ``RETURNING`` clause."
msgstr ""

#: ../../gino.rst:32
msgid "gino.declarative module"
msgstr ""

#: ../../../gino/declarative.pydocstring of gino.declarative.declared_attr:1
msgid "Mark a class-level method as a factory of attribute."
msgstr ""

#: ../../../gino/declarative.pydocstring of gino.declarative.declared_attr:3
msgid ""
"This is intended to be used as decorators on class-level methods of a "
":class:`~Model` class. When initializing the class as well as its "
"subclasses, the decorated factory method will be called for each class, the "
"returned result will be set on the class in place of the factory method "
"under the same name."
msgstr ""

#: ../../../gino/declarative.pydocstring of gino.declarative.declared_attr:9
msgid ""
"``@declared_attr`` is implemented differently than "
":class:`~sqlalchemy.ext.declarative.declared_attr` of SQLAlchemy, but they "
"are both more often used on mixins to dynamically declare indices or "
"constraints (also works for column and ``__table_args__``, or even normal "
"class attributes)::"
msgstr ""

#: ../../../gino/declarative.pydocstring of gino.declarative.declared_attr:38
msgid "This doesn't work if the model already had a ``__table__``."
msgstr ""

#: ../../gino.rst:40
msgid "gino.engine module"
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoConnection:1
msgid "Represents an actual database connection."
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoConnection:3
msgid ""
"This is the root of all query API like :meth:`all`, :meth:`first`, "
":meth:`scalar` or :meth:`status`, those on engine or query are simply "
"wrappers of methods in this class."
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoConnection:7
msgid ""
"Usually instances of this class are created by :meth:`.GinoEngine.acquire`."
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoConnection:11
msgid ""
":class:`.GinoConnection` may refer to zero or one underlying database "
"connection - when a :class:`.GinoConnection` is acquired with ``lazy=True``,"
" the underlying connection may still be in the pool, until a query API is "
"called or :meth:`get_raw_connection` is called."
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoConnection:16
msgid ""
"Oppositely, one underlying database connection can be shared by many "
":class:`.GinoConnection` instances when they are acquired with "
"``reuse=True``. The actual database connection is only returned to the pool "
"when the **root** :class:`.GinoConnection` is released. Read more in "
":meth:`GinoEngine.acquire` method."
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoConnection:24
#: ../../../gino/engine.pydocstring of gino.engine.GinoEngine:11
msgid ":doc:`/engine`"
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoConnection.all:1
msgid "Runs the given query in database, returns all results as a list."
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoConnection.all:3
msgid ""
"This method accepts the same parameters taken by SQLAlchemy "
":meth:`~sqlalchemy.engine.Connectable.execute`. You can pass in a raw SQL "
"string, or *any* SQLAlchemy query clauses."
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoConnection.all:7
msgid ""
"If the given query clause is built by CRUD models, then the returning rows "
"will be turned into relevant model objects (Only one type of model per query"
" is supported for now, no relationship support yet). See "
":meth:`execution_options` for more information."
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoConnection.all:12
msgid ""
"If the given parameters are parsed as \"executemany\" - bulk inserting "
"multiple rows in one call for example, the returning result from database "
"will be discarded and this method will return ``None``."
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoConnection.dialect:1
msgid ""
"The :class:`~sqlalchemy.engine.interfaces.Dialect` in use, inherited from "
"the engine created this connection."
msgstr ""

#: ../../../gino/engine.pydocstring of
#: gino.engine.GinoConnection.execution_options:1
msgid ""
"Set non-SQL options for the connection which take effect during execution."
msgstr ""

#: ../../../gino/engine.pydocstring of
#: gino.engine.GinoConnection.execution_options:4
msgid ""
"This method returns a copy of this :class:`.GinoConnection` which references"
" the same underlying database connection, but with the given execution "
"options set on the copy. Therefore, it is a good practice to discard the "
"copy immediately after use, for example::"
msgstr ""

#: ../../../gino/engine.pydocstring of
#: gino.engine.GinoConnection.execution_options:11
msgid ""
"This is very much the same as SQLAlchemy "
":meth:`~sqlalchemy.engine.base.Connection.execution_options`, it actually "
"does pass the execution options to the underlying SQLAlchemy "
":class:`~sqlalchemy.engine.base.Connection`. Furthermore, GINO added a few "
"execution options:"
msgstr ""

#: ../../../gino/engine.pydocstring of
#: gino.engine.GinoConnection.execution_options:17
msgid ""
"Boolean to control whether the returning results should be loaded into model"
" instances, where the model class is defined in another execution option "
"``model``. Default is ``True``."
msgstr ""

#: ../../../gino/engine.pydocstring of
#: gino.engine.GinoConnection.execution_options:21
msgid ""
"Specifies the type of model instance to create on return. This has no effect"
" if ``return_model`` is set to ``False``. Usually in queries built by CRUD "
"models, this execution option is automatically set. For now, GINO only "
"supports loading each row into one type of model object, relationships are "
"not supported. Please use multiple queries for that. ``None`` for no "
"postprocessing (default)."
msgstr ""

#: ../../../gino/engine.pydocstring of
#: gino.engine.GinoConnection.execution_options:28
msgid ""
"Seconds to wait for the query to finish. ``None`` for no time out (default)."
msgstr ""

#: ../../../gino/engine.pydocstring of
#: gino.engine.GinoConnection.execution_options:31
msgid ""
"A loader expression to load the database rows into specified objective "
"structure. It can be either:  * A model class, so that the query will yield "
"model instances of this   class. It is your responsibility to make sure all "
"the columns of   this model is selected in the query. * A "
":class:`~sqlalchemy.schema.Column` instance, so that each result   will be "
"only a single value of this column. Please note, if you   want to achieve "
"fetching the very first value, you should use   "
":meth:`~gino.engine.GinoConnection.first` instead of   "
":meth:`~gino.engine.GinoConnection.scalar`. However, using directly   "
":meth:`~gino.engine.GinoConnection.scalar` is a more direct way. * A tuple "
"nesting more loader expressions recursively. * A :func:`callable` function "
"that will be called for each row to   fully customize the result. Two "
"positional arguments will be passed   to the function: the first is the "
":class:`row   <sqlalchemy.engine.RowProxy>` instance, the second is a "
"context   object which is only present if nested else ``None``. * A "
":class:`~gino.loader.Loader` instance directly. * Anything else will be "
"treated as literal values thus returned as   whatever they are."
msgstr ""

#: ../../../gino/engine.pydocstring of
#: gino.engine.GinoConnection.execution_options:31
msgid ""
"A loader expression to load the database rows into specified objective "
"structure. It can be either:"
msgstr ""

#: ../../../gino/engine.pydocstring of
#: gino.engine.GinoConnection.execution_options:34
msgid ""
"A model class, so that the query will yield model instances of this class. "
"It is your responsibility to make sure all the columns of this model is "
"selected in the query."
msgstr ""

#: ../../../gino/engine.pydocstring of
#: gino.engine.GinoConnection.execution_options:37
msgid ""
"A :class:`~sqlalchemy.schema.Column` instance, so that each result will be "
"only a single value of this column. Please note, if you want to achieve "
"fetching the very first value, you should use "
":meth:`~gino.engine.GinoConnection.first` instead of "
":meth:`~gino.engine.GinoConnection.scalar`. However, using directly "
":meth:`~gino.engine.GinoConnection.scalar` is a more direct way."
msgstr ""

#: ../../../gino/engine.pydocstring of
#: gino.engine.GinoConnection.execution_options:43
msgid "A tuple nesting more loader expressions recursively."
msgstr ""

#: ../../../gino/engine.pydocstring of
#: gino.engine.GinoConnection.execution_options:44
msgid ""
"A :func:`callable` function that will be called for each row to fully "
"customize the result. Two positional arguments will be passed to the "
"function: the first is the :class:`row <sqlalchemy.engine.RowProxy>` "
"instance, the second is a context object which is only present if nested "
"else ``None``."
msgstr ""

#: ../../../gino/engine.pydocstring of
#: gino.engine.GinoConnection.execution_options:49
msgid "A :class:`~gino.loader.Loader` instance directly."
msgstr ""

#: ../../../gino/engine.pydocstring of
#: gino.engine.GinoConnection.execution_options:50
msgid ""
"Anything else will be treated as literal values thus returned as whatever "
"they are."
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoConnection.first:1
#: ../../../gino/engine.pydocstring of gino.engine.GinoConnection.scalar:1
msgid "Runs the given query in database, returns the first result."
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoConnection.first:3
#: ../../../gino/engine.pydocstring of gino.engine.GinoConnection.scalar:3
msgid "If the query returns no result, this method will return ``None``."
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoConnection.first:5
#: ../../../gino/engine.pydocstring of gino.engine.GinoConnection.scalar:5
msgid "See :meth:`all` for common query comments."
msgstr ""

#: ../../../gino/engine.pydocstring of
#: gino.engine.GinoConnection.get_raw_connection:1
msgid "Get the underlying database connection, acquire one if none present."
msgstr ""

#: ../../../gino/engine.pydocstring of
#: gino.engine.GinoConnection.get_raw_connection:3
msgid "Seconds to wait for the underlying acquiring"
msgstr ""

#: ../../../gino/engine.pydocstring of
#: gino.engine.GinoConnection.get_raw_connection:4
msgid ""
"Underlying database connection instance depending on the dialect in use"
msgstr ""

#: ../../../gino/engine.pydocstring of
#: gino.engine.GinoConnection.get_raw_connection:0
msgid "raises"
msgstr ""

#: ../../../gino/engine.pydocstring of
#: gino.engine.GinoConnection.get_raw_connection:6
msgid ":class:`~asyncio.TimeoutError` if the acquiring timed out"
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoConnection.iterate:1
#: ../../../gino/engine.pydocstring of gino.engine.GinoEngine.iterate:1
msgid "Creates a server-side cursor in database for large query results."
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoConnection.iterate:3
msgid "Cursors must work within transactions::"
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoConnection.iterate:9
msgid "Alternatively, you can manually control how the cursor works::"
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoConnection.iterate:16
msgid "Read more about how :class:`~gino.dialects.base.Cursor` works."
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoConnection.iterate:18
msgid "Similarly, this method takes the same parameters as :meth:`all`."
msgstr ""

#: ../../../gino/engine.pydocstring of
#: gino.engine.GinoConnection.raw_connection:1
msgid ""
"The current underlying database connection instance, type depends on the "
"dialect in use. May be ``None`` if self is a lazy connection."
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoConnection.release:1
msgid "Returns the underlying database connection to its pool."
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoConnection.release:3
msgid ""
"If ``permanent=False``, this connection will be set in lazy mode with "
"underlying database connection returned, the next query on this connection "
"will cause a new database connection acquired. This is useful when this "
"connection may still be useful again later, while some long-running I/O "
"operations are about to take place, which should not take up one database "
"connection or even transaction for that long time."
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoConnection.release:10
msgid ""
"Otherwise with ``permanent=True`` (default), this connection will be marked "
"as closed after returning to pool, and be no longer usable again."
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoConnection.release:14
msgid ""
"If this connection is a reusing connection, then only this connection is "
"closed (depending on ``permanent``), the reused underlying connection will "
"**not** be returned back to the pool."
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoConnection.release:18
msgid ""
"Practically it is recommended to return connections in the reversed order as"
" they are borrowed, but if this connection is a reused connection with still"
" other opening connections reusing it, then on release the underlying "
"connection **will be** returned to the pool, with all the reusing "
"connections losing an available underlying connection. The availability of "
"further operations on those reusing connections depends on the given "
"``permanent`` value."
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoConnection.release:28
#: ../../../gino/engine.pydocstring of gino.engine.GinoEngine.transaction:23
msgid ":meth:`.GinoEngine.acquire`"
msgstr ""

#: ../../../gino/engine.pydocstring of
#: gino.engine.GinoConnection.schema_for_object:1
msgid "A SQLAlchemy compatibility attribute, don't use it for now, it bites."
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoConnection.status:1
msgid "Runs the given query in database, returns the query status."
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoConnection.status:3
msgid ""
"The returning query status depends on underlying database and the dialect in"
" use. For asyncpg it is a string, you can parse it like this: "
"https://git.io/v7oze"
msgstr ""

#: ../../../gino/engine.pydocstring of
#: gino.engine.GinoConnection.transaction:1
msgid "Starts a database transaction."
msgstr ""

#: ../../../gino/engine.pydocstring of
#: gino.engine.GinoConnection.transaction:3
msgid ""
"There are two ways using this method: **managed** as an asynchronous context"
" manager::"
msgstr ""

#: ../../../gino/engine.pydocstring of
#: gino.engine.GinoConnection.transaction:9
msgid "or **manually** awaited::"
msgstr ""

#: ../../../gino/engine.pydocstring of
#: gino.engine.GinoConnection.transaction:19
msgid ""
"Where the ``tx`` is an instance of the "
":class:`~gino.transaction.GinoTransaction` class, feel free to read more "
"about it."
msgstr ""

#: ../../../gino/engine.pydocstring of
#: gino.engine.GinoConnection.transaction:23
msgid ""
"In the first managed mode, the transaction is automatically committed on "
"exiting the context block, or rolled back if an exception was raised which "
"led to the exit of the context. In the second manual mode, you'll need to "
"manually call the :meth:`~gino.transaction.GinoTransaction.commit` or "
":meth:`~gino.transaction.GinoTransaction.rollback` methods on need."
msgstr ""

#: ../../../gino/engine.pydocstring of
#: gino.engine.GinoConnection.transaction:30
msgid ""
"If this is a lazy connection, entering a transaction will cause a new "
"database connection acquired if none was present."
msgstr ""

#: ../../../gino/engine.pydocstring of
#: gino.engine.GinoConnection.transaction:33
msgid ""
"Transactions may support nesting depending on the dialect in use. For "
"example in asyncpg, starting a second transaction on the same connection "
"will create a save point in the database."
msgstr ""

#: ../../../gino/engine.pydocstring of
#: gino.engine.GinoConnection.transaction:37
msgid ""
"For now, the parameters are directly passed to underlying database driver, "
"read :meth:`asyncpg.connection.Connection.transaction` for asyncpg."
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoEngine:1
msgid ""
"Connects a :class:`~.dialects.base.Pool` and "
":class:`~sqlalchemy.engine.interfaces.Dialect` together to provide a source "
"of database connectivity and behavior."
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoEngine:5
msgid ""
"A :class:`.GinoEngine` object is instantiated publicly using the "
":func:`gino.create_engine` function or :func:`db.set_bind() "
"<gino.api.Gino.set_bind>` method."
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoEngine.acquire:1
msgid "Acquire a connection from the pool."
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoEngine.acquire:3
msgid ""
"There are two ways using this method - as an asynchronous context manager::"
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoEngine.acquire:9
msgid ""
"which will guarantee the connection is returned to the pool when leaving the"
" ``async with`` block; or as a coroutine::"
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoEngine.acquire:18
msgid ""
"where the connection should be manually returned to the pool with "
":meth:`conn.release() <.GinoConnection.release>`."
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoEngine.acquire:21
msgid ""
"Within the same context (usually the same :class:`~asyncio.Task`, see also "
":doc:`/transaction`), a nesting acquire by default re"
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoEngine.acquire:24
msgid ""
"Block up to ``timeout`` seconds until there is one free connection in the "
"pool. Default is ``None`` - block forever until succeeded. This has no "
"effect when ``lazy=True``, and depends on the actual situation when "
"``reuse=True``."
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoEngine.acquire:29
msgid ""
"Reuse the latest reusable acquired connection (before it's returned to the "
"pool) in current context if there is one, or borrow a new one if none "
"present. Default is ``False`` for always borrow a new one. This is useful "
"when you are in a nested method call series, wishing to use the same "
"connection without passing it around as parameters. See also: "
":doc:`/transaction`. A reusing connection is not reusable even if "
"``reusable=True``. If the reused connection happened to be a lazy one, then "
"the reusing connection is lazy too."
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoEngine.acquire:38
msgid ""
"Don't acquire the actual underlying connection yet - do it only when needed."
" Default is ``False`` for always do it immediately. This is useful before "
"entering a code block which may or may not make use of a given connection "
"object. Feeding in a lazy connection will save the borrow-return job if the "
"connection is never used. If setting ``reuse=True`` at the same time, then "
"the reused connection - if any - applies the same laziness. For example, "
"reusing a lazy connection with ``lazy=False`` will cause the reused "
"connection to acquire an underlying connection immediately."
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoEngine.acquire:48
msgid ""
"Mark this connection as reusable or otherwise. This has no effect if it is a"
" reusing connection. All reusable connections are placed in a stack, any "
"reusing acquire operation will always reuse the top (latest) reusable "
"connection. One reusable connection may be reused by several reusing "
"connections - they all share one same underlying connection. Acquiring a "
"connection with ``reusable=False`` and ``reusing=False`` makes it a cleanly "
"isolated connection which is only referenced once here."
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoEngine.acquire:57
msgid "A :class:`.GinoConnection` object."
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoEngine.all:1
msgid ""
"Acquires a connection with ``reuse=True`` and runs "
":meth:`~.GinoConnection.all` on it. ``reuse=True`` means you can safely do "
"this without borrowing more than one underlying connection::"
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoEngine.all:8
msgid "The same applies for other query methods."
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoEngine.close:1
msgid "Close the engine, by closing the underlying pool."
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoEngine.compile:1
msgid ""
"A shortcut for :meth:`~gino.dialects.base.AsyncDialectMixin.compile` on the "
"dialect, returns raw SQL string and parameters according to the rules of the"
" dialect."
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoEngine.connection_cls:1
msgid ""
"Customizes the connection class to use, default is :class:`.GinoConnection`."
msgstr ""

#: ../../../gino/engine.pydocstring of
#: gino.engine.GinoEngine.current_connection:1
msgid ""
"Gets the most recently acquired reusable connection in the context. ``None``"
" if there is no such connection."
msgstr ""

#: ../../../gino/engine.pydocstring of
#: gino.engine.GinoEngine.current_connection:4
msgid ":class:`.GinoConnection`"
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoEngine.dialect:1
msgid ""
"Read-only property for the :class:`~sqlalchemy.engine.interfaces.Dialect` of"
" this engine."
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoEngine.first:1
msgid "Runs :meth:`~.GinoConnection.first`, See :meth:`.all`."
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoEngine.iterate:3
msgid ""
"This requires that there is a reusable connection in the current context, "
"and an active transaction is present. Then its "
":meth:`.GinoConnection.iterate` is executed and returned."
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoEngine.raw_pool:1
msgid ""
"Read-only access to the underlying database connection pool instance. This "
"depends on the actual dialect in use, :class:`~asyncpg.pool.Pool` of asyncpg"
" for example."
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoEngine.scalar:1
msgid "Runs :meth:`~.GinoConnection.scalar`, See :meth:`.all`."
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoEngine.status:1
msgid "Runs :meth:`~.GinoConnection.status`. See also :meth:`.all`."
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoEngine.transaction:1
msgid "Borrows a new connection and starts a transaction with it."
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoEngine.transaction:3
msgid ""
"Different to :meth:`.GinoConnection.transaction`, transaction on engine "
"level supports only managed usage::"
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoEngine.transaction:9
msgid ""
"Where the implicitly acquired connection is available as "
":attr:`tx.connection <gino.transaction.GinoTransaction.connection>`."
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoEngine.transaction:12
msgid ""
"By default, :meth:`.transaction` acquires connection with ``reuse=True`` and"
" ``reusable=True``, that means it by default tries to create a nested "
"transaction instead of a new transaction on a new connection. You can change"
" the default behavior by setting these two arguments."
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoEngine.transaction:18
msgid ""
"The other arguments are the same as :meth:`~.GinoConnection.transaction` on "
"connection."
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoEngine.transaction:25
msgid ":meth:`.GinoConnection.transaction`"
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoEngine.transaction:27
msgid ":class:`~gino.transaction.GinoTransaction`"
msgstr ""

#: ../../../gino/engine.pydocstring of gino.engine.GinoEngine.transaction:29
msgid ""
"A asynchronous context manager that yields a "
":class:`~gino.transaction.GinoTransaction`"
msgstr ""

#: ../../../gino/engine.pydocstring of
#: gino.engine.GinoEngine.update_execution_options:1
msgid ""
"Update the default execution_options dictionary of this "
":class:`.GinoEngine`."
msgstr ""

#: ../../../gino/engine.pydocstring of
#: gino.engine.GinoEngine.update_execution_options:6
msgid ":meth:`sqlalchemy.engine.Engine.update_execution_options`"
msgstr ""

#: ../../../gino/engine.pydocstring of
#: gino.engine.GinoEngine.update_execution_options:8
msgid ":meth:`.GinoConnection.execution_options`"
msgstr ""

#: ../../gino.rst:48
msgid "gino.exceptions module"
msgstr ""

#: ../../../gino/exceptions.pydocstring of gino.exceptions.GinoException:1
msgid "Bases: :class:`Exception`"
msgstr ""

#: ../../../gino/exceptions.pydocstring of gino.exceptions.NoSuchRowError:1
#: ../../../gino/exceptions.pydocstring of
#: gino.exceptions.UninitializedError:1
msgid "Bases: :class:`gino.exceptions.GinoException`"
msgstr ""

#: ../../gino.rst:56
msgid "gino.json\\_support module"
msgstr ""

#: ../../../gino/json_support.pydocstring of
#: gino.json_support.StringProperty:1 ../../../gino/json_support.pydocstring
#: of gino.json_support.DateTimeProperty:1
#: ../../../gino/json_support.pydocstring of
#: gino.json_support.IntegerProperty:1 ../../../gino/json_support.pydocstring
#: of gino.json_support.BooleanProperty:1
#: ../../../gino/json_support.pydocstring of
#: gino.json_support.ObjectProperty:1 ../../../gino/json_support.pydocstring
#: of gino.json_support.ArrayProperty:1
msgid "Bases: :class:`gino.json_support.JSONProperty`"
msgstr ""

#: ../../gino.rst:64
msgid "gino.loader module"
msgstr ""

#: ../../../gino/loader.pydocstring of gino.loader.AliasLoader:1
msgid "Bases: :class:`gino.loader.ModelLoader`"
msgstr ""

#: ../../../gino/loader.pydocstring of gino.loader.CallableLoader:1
#: ../../../gino/loader.pydocstring of gino.loader.ColumnLoader:1
#: ../../../gino/loader.pydocstring of gino.loader.ModelLoader:1
#: ../../../gino/loader.pydocstring of gino.loader.TupleLoader:1
#: ../../../gino/loader.pydocstring of gino.loader.ValueLoader:1
msgid "Bases: :class:`gino.loader.Loader`"
msgstr ""

#: ../../gino.rst:72
msgid "gino.schema module"
msgstr ""

#: ../../../gino/schema.pydocstring of gino.schema.AsyncSchemaDropper:1
msgid ""
"Bases: :class:`gino.schema.AsyncVisitor`, "
":class:`sqlalchemy.sql.ddl.SchemaDropper`"
msgstr ""

#: ../../../gino/schema.pydocstring of gino.schema.AsyncSchemaGenerator:1
msgid ""
"Bases: :class:`gino.schema.AsyncVisitor`, "
":class:`sqlalchemy.sql.ddl.SchemaGenerator`"
msgstr ""

#: ../../gino.rst:80
msgid "gino.strategies module"
msgstr ""

#: ../../../gino/strategies.pydocstring of gino.strategies.GinoStrategy:1
msgid "Bases: :class:`sqlalchemy.engine.strategies.EngineStrategy`"
msgstr ""

#: ../../../gino/strategies.pydocstring of
#: gino.strategies.GinoStrategy.create:1
msgid "Given arguments, returns a new Engine instance."
msgstr ""

#: ../../gino.rst:88
msgid "gino.transaction module"
msgstr ""

#: ../../../gino/transaction.pydocstring of gino.transaction.GinoTransaction:1
msgid ""
"Represents an underlying database transaction and its connection, offering "
"methods to manage this transaction."
msgstr ""

#: ../../../gino/transaction.pydocstring of gino.transaction.GinoTransaction:4
msgid ""
":class:`.GinoTransaction` is supposed to be created by either "
":meth:`gino.engine.GinoConnection.transaction`, or "
":meth:`gino.engine.GinoEngine.transaction`, or "
":meth:`gino.api.Gino.transaction`, shown as follows::"
msgstr ""

#: ../../../gino/transaction.pydocstring of
#: gino.transaction.GinoTransaction:26
msgid ""
"When in use with asynchronous context manager, :class:`.GinoTransaction` "
"will be in **managed** mode, while the last example with ``await`` will put "
"the :class:`.GinoTransaction` in **manual** mode where you have to call the "
":meth:`.commit` or :meth:`.rollback` to manually close the transaction."
msgstr ""

#: ../../../gino/transaction.pydocstring of
#: gino.transaction.GinoTransaction:31
msgid ""
"In **managed** mode the transaction will be automatically committed or "
"rolled back on exiting the ``async with`` block depending on whether there "
"is an exception or not. Meanwhile, you can explicitly exit the transaction "
"early by :meth:`.raise_commit` or :meth:`.raise_rollback` which will raise "
"an internal exception managed by the asynchronous context manager and "
"interpreted as a commit or rollback action. In a nested transaction "
"situation, the two exit-early methods always close up the very transaction "
"which the two methods are referenced upon - all children transactions are "
"either committed or rolled back correspondingly, while no parent transaction"
" was ever touched. For example::"
msgstr ""

#: ../../../gino/transaction.pydocstring of
#: gino.transaction.GinoTransaction:55
msgid ""
"The internal exception raised from :meth:`.raise_commit` and "
":meth:`.raise_rollback` is a subclass of :exc:`BaseException`, so normal "
"``try ... except Exception:`` can't trap the commit or rollback."
msgstr ""

#: ../../../gino/transaction.pydocstring of
#: gino.transaction.GinoTransaction.commit:1
msgid "Only available in manual mode: manually commit this transaction."
msgstr ""

#: ../../../gino/transaction.pydocstring of
#: gino.transaction.GinoTransaction.connection:1
msgid ""
"Accesses to the :class:`~gino.engine.GinoConnection` of this transaction. "
"This is useful if when the transaction is started from ``db`` or ``engine`` "
"where the connection is implicitly acquired for you together with the "
"transaction."
msgstr ""

#: ../../../gino/transaction.pydocstring of
#: gino.transaction.GinoTransaction.raise_commit:1
msgid ""
"Only available in managed mode: skip rest of the code in this transaction "
"and commit immediately by raising an internal exception, which will be "
"caught and handled by the asynchronous context manager::"
msgstr ""

#: ../../../gino/transaction.pydocstring of
#: gino.transaction.GinoTransaction.raise_rollback:1
msgid ""
"Only available in managed mode: skip rest of the code in this transaction "
"and rollback immediately by raising an internal exception, which will be "
"caught and handled by the asynchronous context manager::"
msgstr ""

#: ../../../gino/transaction.pydocstring of
#: gino.transaction.GinoTransaction.raw_transaction:1
msgid ""
"Accesses to the underlying transaction object, whose type depends on the "
"dialect in use."
msgstr ""

#: ../../../gino/transaction.pydocstring of
#: gino.transaction.GinoTransaction.rollback:1
msgid "Only available in manual mode: manually rollback this transaction."
msgstr ""

#: ../../gino.rst:97
msgid "Module contents"
msgstr ""
